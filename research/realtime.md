First source:
2 From Mathematical Descriptions to ProgramsPrograms implementing control systems differ from their correspondingdiscrete-time recurrence equations in several aspects, the first of which isnot particular to control systems but is concerned with different levels of ab-straction in which algorithms can be described. For instance, algorithms forsearching directed graphs may be defined in terms of the abstract structure ofthe graph, the mathematical G = (V, E), without paying attention to the waythe graph is stored in memory. An abstract algorithm may contain statementssuch as “for each successor of a vertex v do” without being explicit about theway the successors of a node are retrieved from the data structure representingthe graph. More concrete programs, written in languages such as C, need tospecify these details. Between these levels and the actual physical realizationthere are many intermediate levels (assembly and machine code, micro code,architecture, etc.) and one of the great achievements of computer science andengineering is that most of the transformations between these levels are doneautomatically using computer programs.As an illustrative example we consider one of the most popular forms ofcontrol, the PID controller, and see how it is transformed into a program.An important feature of feedback functions is that they are typically dynam-ical systems by themselves, admitting a state which influences their outputand future behavior. Fig. 2 shows the Simulink diagram of a typical sampled-data PID controller. The annotation of the Simulink blocks is written in thez-transform formalism, which is a discrete version of a frequency-domain rep-resentation of systems, where delay and memory are expressed using the 1/zoperator. An explanation of this formalism can be found elsewhere in thehandbook, and we focus here on a more “mechanical” state-space descriptionof the controller. What a PID controller essentially does is to take the inputsignal I, compute its derivative D and integral S and then compute the outputO as some linear combination of I, S and D. The state variables of the systeminclude the integral S and the previous value of the input J, which is neededfor computing the derivative. The following system of recurrence equationsdefines the semantics of the controller as a set On of output sequences whoserelation with the input sequence In is defined byS−1 = I−1 = 0.0Sn = Sn−1 + 0.1 · InOn = 5.8 · In + 4 · Sn + 3.8 · 10.0 · (In − In−1)(1)The first line defines the initial values of state variable S and the second linedefines its subsequent value for every n ≥ 0. The last line determines theoutput, using In − In−1 as the derivative. Since old values of the input are nottypically kept in memory, we will need to store this information in an auxiliarystate variable J satisfying Jn = In, and replacing In−1 in the definition of Onby Jn−1.
6 P. Caspi and O. Maler1Out10.1zz−1Integrator5.8Gain23.8Gain14Gainz−10.1zDerivative1In1Fig. 2. A PID controller represented by a Simulink block diagramBefore showing the corresponding program, let us note that since (1) in-volves memory that has to be maintained and propagated between successiveinvocations of the program, the corresponding programming construct is bet-ter viewed as a class in an object-oriented language such as C++ or Java.However, since this point of view is probably not so familiar to most readers,we will realize it as a C program with global variables. These variables con-tinue to exist between successive invocations of the program (like latches insequential digital circuits when the clock signal is low). The program shownin Table 1 is a result of a rather straightforward transformation of (1)./* memories */float S = 0.0, J = 0.0;void dispid cycle (){float I,O;float J 1,S 1;I = Input();J 1 = I;S 1 = S + 0.1 * I * 4.0;O = I * 5.8 + S 1 + 10.0 * 3.8 * (I-J);J = J 1;S = S 1;Output(O);}Table 1. A program realizing a PID controller
From Control Loops to Real-Time Programs 7The first part of the program is the declaration and initialization of theglobal variables J and S. The second part, the dispid cycle procedure, de-scribes the computation to be performed at each invocation of the program. Ituses auxiliary variables J 1 and S 1 into which the new state is computed. Theprocedure presupposes two auxiliary functions Input and Output provided bythe execution platform, which take care of bringing (digitized) sensor inputsinto I and writing O onto the actuators. The implementation details of thesefunctions are outside the scope of this article. The computational part of theprocedure consists of taking the input and propagating it through a networkof computations to produce the output. We first compute the next values ofthe state variables, then compute the output, write the new state values intothe global variables and finally write the output and exit.Upon closer inspection one can see that we do not really need the auxiliaryvariable S 1 because only the new value of S is used while computing O. Con-sequently, we can replace the computation of S 1 by direct computation of S,use S in the computation of O and discard the assignment statement S = S 1.In fact, we can do similar things with J, by putting the statement J=I afterthe computation of the output, to obtain the optimized program in Table 2./* memories */float S = 0.0, J = 0.0;void dispid cycle (){float I,O;I = Input();S = S +0.1 * I * 4.0;O = I * 5.8 + S + 10.0 * 3.8 * (I-J);J = I;Output(O);}Table 2. An optimized program for the PID controllerSaving two variables and two assignment statements is not much, butfor complex control systems that should run on cheap micro controllers, theaccumulated effect of such savings can be significant.The reader can easily appreciate that the process of writing, modifying andoptimizing such programs manually is error prone and that it would be muchsafer to derive it automatically from the high-level Simulink model. We havederived a program similar to the program in Table 2 from the Simulink modelof Figure 2 in two steps. First, the Simulink-to-Lustre translator [6] was used totransform the model into a program in Lustre, a language [11] which provides
8 P. Caspi and O. Malerrigorous syntax and semantics for expressing data-flow equations such as (1).Then the Reluc Lustre-to-C code generator [9] produced the program afterautomatic analysis of state variables, dependencies and other optimizations.The story does not end with the generation of machine code by the C com-piler, as there are some additional conditions associated with the executionplatform that need to be met. To begin with, the platform should support theI/O functions and be properly connected to all the machinery for conversionbetween digital and analog data. Second, the proper functioning of the pro-gram depends crucially on its being invoked every T time units, where T is thesampling period of the discrete-time system according to which the parame-ters of the PID controller were derived. Not adhering to this sampling periodmay result in a strong deviation of the program behavior from the intendedone. This is a very particular (and rather unexpected) class of software errorsinherent in control applications.To ensure the correct periodic activation of the program we need accessto a real-time clock that will trigger the execution every T time units. Butthis is not enough due to yet another important difference between an ab-stract mathematical function and a program that computes it: the former istimeless while the latter takes some time to compute. For a program suchas dispid cycle to function, the condition C < T should hold, where C isits worst-case execution time (WCET). If this requirement is not met, theprogram will not terminate before its next invocation (see the timing diagramin Fig. 3). Measuring and estimating the WCET of a program on a givenarchitecture is not an easy task, especially for modern processors, and it issubject to extensive ongoing research [25].Read Compute Idle Read ComputeCT. . .IdleWriteWriteFig. 3. The execution of a control program with a period TOnce these conditions are fulfilled, several implementation techniques canbe used. Historically, such controllers were first implemented on a bare ma-chine, without using any operating system (OS). The real-time clock acts asan interrupt that transfers control to the program. If the scheduling conditionC < T is satisfied, this interrupt occurs after the program has terminated andthe computer is idle. Hence, unlike preemptive scheduling, there is no need forcontext switching and complex OS services. This implementation techniqueis thus both simple and safe and does not need to rely on a complex piece
From Control Loops to Real-Time Programs 9of software like an OS, which is difficult to validate. Much progress has beenmade in real-time OS (RTOS) technology, and today commercial systems areavailable that have been exercised and debugged by a large number of usersand can be considered quite safe. Hence the role of monitoring the real-timeclock and dispatching the program for execution can be delegated to an OS.This concludes the discussion on the implementation of simple controlprograms where we have tried to touch upon the key relevant computationalaspects. In the next section we focus on the timing-related aspects of imple-menting more complex control loops.3 Complex Periodic ControllersIn many control applications, systems have several degrees of freedom thatmust be controlled simultaneously. Mathematically each controller ci is justanother recurrence equation that coexists with the other equations. Compu-tationally, these loops should be realized on a sequential computer that cando one thing at a time. The problem of how to “sequentialize” and schedulethese parallel processes is one of the major topics in real-time systems. It isimportant that each invocation of a controller will have its relevant inputsready before it starts executing and that the computation of all its outputsand their transmission to the outside world terminate in due time. This is thebasic functional requirement from real-time control software, a fact sometimesobscured by details of operating systems and scheduling policies. 

Reference: 
Paul Caspi and Oded Maler. From Control Loops to Real-Time Programs. Verimag-CNRS, France.[ http://arpont.imag.fr/~maler/Papers/caspimaler.pdf]
Second source:
30 янв., 12.56​.aac
Speaker1: [00:00:00] Yes. So it's going to be real time, right?

Speaker2: [00:00:06] Because it's typically real time. So you can imagine a robotic arm. It's moving at some velocity and it needs to know how much it's going to overshoot. It can compute that based on the current velocity, but it's not until it observes each error component that it can work out how much to slow down by it. So it's a real time component.

Speaker1: [00:00:22] Mainly because why am I? Raspberry Pi and PID  regulator in Python are just not well. Understand how it works.

Speaker2: [00:00:34] Yes, a python isn't really  good a language for this . I would I would say real time.

Speaker1: [00:00:38] It's not really real time controller.

Speaker2: [00:00:42] No. Right. Mean. Well, but the thing is a Raspberry Pi has an operating system on it. Right. And that's not typically real time. Things can happen. You know, you can get an interrupt to service something, but the Raspberry Pi is not the best solution for a real time. But you can use it because a tremendously fast if it's faster than what you sort of sampling or calculating, then yeah, it's ideal for that. But but Python is not really the fastest or best language, I would say. I would say if you want to avoid an interpreted language or something that's just in time compiled, you want, you want deterministic nature, something like that.

Speaker1: [00:01:21] Yeah. Interpret language. Give them time. So you're talking about the real time system?

Speaker2: [00:01:27] Yeah.


Speaker2: [00:01:33] Yeah. Yeah, well, the thing is, we've just been compiler. You can have things that make, you know, on the fly optimization. So if it can see your for loop is going to last for 10,000 cycles or 10,000 iterations and nothing's going to change there just in time. Compiler can optimize quite a lot and say, Oh, you're not changing during that time. We can just not doing the full loop. But in your mind, if it was to do something like delay for X amount of time and it's just remove that, then you're going to have trouble. So you want the deterministic compiled language for something like a PID controller.

Speaker1: [00:02:06] So ideally should be the compile language and real time.

Speaker2: [00:02:11] Yes. Ideally, yes. So what project is it you want?

Speaker1: [00:02:14] It's like my extra project that I'm doing for fun at Drone.

Speaker2: [00:02:19] Okay, awesome.

Speaker1: [00:02:20] So it's actually not really a drone. It's actually a platform where the humans can take our controller. So maybe you maybe you care about butterflies or. It's wrong. But the thing is, did you buy the butterfly butterfly controller? And this.

Speaker2: [00:02:37] Is you want to make a fortune for.

Speaker1: [00:02:40] It. So if you need something else to. Can't do that. You can.

Speaker2: [00:02:47] Use. So you want enough speed to sample error times. So your pitch and your write, your role and azimuth. You need enough computational speed to calculate by how much you need to correct. So something in the order of, say, 100 megahertz or higher would be ideal for that. Now, if you imagine your Raspberry Pi, it's got processes in the background that are happening sort of asynchronously, right? And that's not ideal because if one of the threads then suddenly pipes up and it's like, I want to, I want all the CPU resources, then you're controlling the controls, the the correction for the angle momentum is then going to suffer. It's not going to have enough time. So it's then probably going to crash. So we use things like DSP or digital signal processor for real time stuff. 

Speaker1: [00:03:39] Really good example. Yeah. I mean, I'm working through it.

Reference: Nathan Barbon. What OS type for robust system (robot and drones). 30/01/2023.

Third source

After the experiment is completed, the 63.2% method (section 3.3.1.1) isimplemented. The implementation starts by calculating time delay L. To calculate thetime delay, variance of the last 5 measured temperatures is used. When a significantchange on the measured outputs is identified, the time when this change occurs issaved. The difference between the time found and the time the step input wasapplied is the time delay. Figure 4.19 shows the system_response() method and thecode that uses it to estimate time delay L.


4.3.5 Other practical considerations for PID controllerIn addition to the procedure described in the previous sections, there are also otherminor details that should be considered while implementing a PID controller. Suchconsiderations include the units that should be used, the duration of the timesampling period and the integrator windup problem.The integrator windup problem is probably the most important of these detailsas if it is not taken under consideration it could vastly increase the oscillations in thesystem control procedure. Integrator windup is a problem that commonly occurswhen the Ki gain value is considerably large compared to Kp and Kd and the controlaction that needs to be taken exceeds the physical capabilities of the system. Asdescribed in the previous section the I term of the PID controller is the result of themultiplication of the Ki value with the sum of the errors occurred up to that point(the Integrator). While the process output is lower than the set point, the error ispositive and is added to the Integrator (the sum of all past errors). If the processoutput remains lower than the set point for a considerable amount of time theIntegrator grows larger and larger up to the point that the I term dominates the Pand D terms and the controller output reaches the maximum or minimum point, e.g.100% or 0%. The integrator will continue to grow until the set point has beenreached even though there is no point of further increasing the integrator as themaximum or minimum physical limit has already been reached. Until the time that
66 | Pagethe set point is reached the Integrator will be large and this will result to overshootor response delay as the output of the controller will not reduce to the rate it should.After the overshoot or the delay the Integrator will start to wind down as itaccumulates negative error which will result to the restoration of the Integrator to avalue close to zero. However, this procedure will take a considerable amount of timeand the set point has already been passed. This problem is a result of the inability ofthe controller to consider the physical limitations of the system. For instance, if thecontroller calculates that the required output to reach the set point is 2000%, theoutput to the heater will be limited to 100%, as the heaters cannot be powered bymore than full power. Figure 4.26 shows an example to better illustrate the effectand importance of the integrator windup problem.In the example, the controller output is limited by the physical system characteristics(shown in the bottom graph) and as a result a considerable amount of positive erroris accumulated in the Integrator (shown in the top graph). The operator using thecontroller sees that the process output will never reach the set point, due to thelimitation of the controller output, and decides to reduce the set point. When thechange in the set point occurs there is a significant delay until the controllerresponds by lowering its output. This happens because the integrator already has alarge positive value that dominates the controller output and it takes some time forthe negative error to wind down the integrator. The controller responds whenadequate negative error is summed to the integrator to cancel out the positive error.Figure 4.26. Integrator windup effect. Top graphshows the process output and bottom graphshows controller output, redrawn from ref
67 | PageThere are several solutions to solve this problem. In this case, clamping of thecontroller output is used as the solution. Using this method, if the controller outputis larger or smaller than then physical limit, e.g. 100% or 0%, the controller output issimply set to that limit. In addition, when the controller output is set to themaximum or minimum limit, the integrator stops accumulating any more error. Theintegrator restarts accumulating error when the value drops again between thephysical range or when the sign of the error is changed (the set point has beenpassed). This way the response of the controller is faster when needed. Figure 4.27shows the implementation of anti-windup method.if PID > 100:PID = 100if self.set_point > current_value:self.Integrator_flag = Falseelse:self.Integrator_flag = Trueelif PID < 0:PID = 0if self.set_point < current_value:self.Integrator_flag = Falseelse:self.Integrator_flag = Trueelse:self.Integrator_flag = TruePID is the controller output value, which is clamped between 0 and 100.Other considerations include the time period between the controller output and themeasurement of the process output (e.g. the temperature). This period is called thesampling time or period of the system. The rule of thumb is that the sampling timeshould be equal or smaller than the 1/10th of the time delay T. So for example ifT is equal to 30 the sampling time should be 3 seconds or less. Generally, at least 10measurements should be taken every T seconds.Another minor but important issue is the units used for the controller input, thecontroller output, the set point and the process output. The process output and theset point should be expressed in the same units, as their difference will produce theerror value. For example, the process output and the set point can be in degreesCelsius. To produce controller output that corresponds to the 0-100% range it is alsoimportant that the process input used in the system identification experiments isalso in percentage and also in the same 0-100% range.
Reference: 
FEIDIAS IOANNIDIS. INTELLIGENT CONTROLLER BASED ONRASPBERRY PI. University of Manchester, SCHOOL OF COMPUTER SCIENCE. 2014.  [https://studentnet.cs.manchester.ac.uk/resources/library/thesis_abstracts/MSc14/FullText/Ioannidis-Feidias-fulltext.pdf].


So your final desition is to patch linux code for real time 
